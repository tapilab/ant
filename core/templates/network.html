{% extends "base.html" %}
{% load static %}
{% block css %}
    <style>
        .node {
            stroke: #fff;
            stroke-width: 2px;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        
        .mytooltip {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 5px;
            display: none;
            max-width: 200px; /* Set maximum width here */
        }
        .highlighted {
            /* fill: yellow; /* Change the fill color to highlight */
            stroke: yellow;
            stroke-width: 4px;
            r: 15;
        }        
        .highlighted_link {
            stroke: yellow; /* Change the color to a desired color */
            stroke-width: 10px; /* Increase the width to a desired value */
        }
        .mycontainer {
            left: 5vw;
        }

        #searchContainer {
/*            position: absolute;
            top: 100px; /* Adjust the top position as needed */
            left: 5vw; /* Adjust the left position as needed */
            z-index: 500; /* Ensure the search input is above other elements */
*/        }    
        svg {
            width: 100%; /* 90vw;*/
            height: 90vh; /* fraction of screen */
            background-color: whitesmoke; /* Optional: Add background color */
        }       
        #details {
/*            width: 10vw; /* Set the width as needed */
/*            height: 90vh; /* Set the height as needed */
/*            background-color: lightgray; /* Set the background color */*/
/*            position: absolute;*/
/*            top: 0; /* Adjust the top position as needed */*/
/*            left: calc(100% + 1px); /* Position to the right of the svg element */*/*/
*/        }     
        #button-container {
            margin-bottom: 10px;
        }
        .button {
            margin-right: 5px;
        }
        .active {
            background-color: green; /* Change the background color for active buttons */
        }

    </style>
{% endblock %}

{% block content %}

<div class="mycontainer">
    <div class="row">
        <!-- Toggle buttons -->
        <div id="button-container" class="col-md-4"></div>
        <!-- Search bar -->
        <div id="searchContainer" class="col-md-4">
            search: <input type="text" id="searchInput" placeholder="Search for nodes...">
        </div>
    </div>
    <div class="row">
        <!-- Network -->
        <div class="col-md-9">
            <svg id="network">hello</svg>
        </div>
        <!-- Entity details -->
        <div class="col-md-3">
            <div id="details"></div>
        </div>
    </div>
</div>
<!-- Tooltip -->
<div id="mytooltip" class="mytooltip">
        <div id="mytooltipText"></div>
    	<img id="mytooltipImage" src="" alt="Tooltip Image" style="max-width: 100px; max-height: 100px;">
</div>
{% endblock %}

{% block scripts %}
<script>
    // Create network.
    const svg = d3.select("#network");
	var networkData = {{ network_json|safe }};
	const nodes = networkData.nodes;
	const links = networkData.links;

    const network_group = svg.append("g")
    .attr("id", "network-group");

    const link = network_group.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("class", "link")
        .attr("stroke-width", 2)
        .style("visibility", "visible"); // Ensure links are visible


    const node = network_group.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", 8)
        .attr("fill", d => d.color)
        .on("mouseover", showTooltip)
        .on("mouseout", hideTooltip)
        .on("click", handleClick)
        .style("visibility", "visible"); // Ensure links are visible

    const width = svg.node().getBoundingClientRect().width;
    const height = svg.node().getBoundingClientRect().height;

    // Add toggle buttons
    const buttonContainer = d3.select("#button-container");
    const entityTypes = Array.from(new Set(nodes.map(node => node.entity_type)));
    entityTypes.forEach(entityType => {
        buttonContainer.append("button")
            .attr("class", "button active")
            .text(entityType)
            .on("click", function() {
                const isVisible = d3.select(this).classed("active");
                d3.select(this).classed("active", !isVisible);
                toggleNodes(entityType, !isVisible);
            });
        // Show nodes for the initial 'active' buttons
        toggleNodes(entityType, true);            
    });

    // Function to toggle nodes visibility based on entity type
    function toggleNodes(entityType, isVisible) {
        // First, toggle the visibility of the nodes of the specified type.
        const nodesToToggle = node.filter(d => d.entity_type === entityType);
        nodesToToggle.each(function(d) {
            d.isVisible = !d.isVisible; // Add an 'isVisible' property to toggle and track visibility state
        }).style("visibility", function(d) {
            return d.isVisible ? "visible" : "hidden";
        });

        // Then, for each link, determine its visibility based on the visibility of its source and target nodes.
        link.style("visibility", function(d) {
            // A link is visible only if both source and target nodes are visible.
            const sourceVisibility = d.source.isVisible !== false; // Treat undefined as true for initial state
            const targetVisibility = d.target.isVisible !== false;
            return sourceVisibility && targetVisibility ? "visible" : "hidden";
        });

    };    

    // Layout network.
    const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(100))
        .force("charge", d3.forceManyBody().strength(-50)) // was -100
        // .force("center", d3.forceCenter(svg.clientWidth / 2, svg.clientHeight / 2));
        .force("center", d3.forceCenter(width / 2, height / 2));

    let tickCount = 0;
    simulation.on("tick", () => {
        tickCount++;
        // Zoom out and refit every three iterations.
        if (tickCount % 3 == 0) {
            fitScreen();
        }
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        node
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);
    })
    .on('end', function() {
        console.log('simulation end!!');
        fitScreen();
    });

    // Zoom out and center.
    function fitScreen() {
        const searchTerm = getQueryParam("search");
        if (searchTerm != null) {
            filterNodes(searchTerm.trim());
        } else {
            var bounds = network_group.node().getBBox();
            var centerX = bounds.x + bounds.width / 2;
            var centerY = bounds.y + bounds.height / 2;
            var scale = Math.min(width / bounds.width, height / bounds.height) * 1.05;
            var translateX = width / 2 - centerX * scale;
            var translateY = height / 2 - centerY * scale;

            svg.transition().duration(500).call(
                zoom.transform,
                d3.zoomIdentity.translate(translateX, translateY).scale(scale)
            );
        }
    }

    // Tooltip
    function showTooltip(event, d) {
        const tooltip = d3.select("#mytooltip");
        const tooltipImage = d3.select("#mytooltipImage");
        const tooltipText = d3.select("#mytooltipText");

        tooltipText.text(d.name);

		if (d.image_url) {
	        tooltipImage.style("display", "block")
	                     .attr("src", d.image_url);
		} else {
	        tooltipImage.style("display", "none");
		}

        tooltip.style("display", "block")
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 20) + "px");
    }

    function hideTooltip() {
        d3.select("#mytooltip").style("display", "none");
    }


    // Add a click event listener to the SVG canvas
    svg.on("click", () => {
        // Remove the highlighted class from all nodes
        node.classed("highlighted", false);
        link.classed("highlighted_link", false);
    });

    // Define the handleClick function
    function handleClick(event, clickedNode) {
        // Get the IDs of connected nodes
        const connectedNodeIds = links
            .filter(link => link.source === clickedNode || link.target === clickedNode)
            .map(link => link.source === clickedNode ? link.target.id : link.source.id);

        // Remove highlighting from previously clicked nodes (if any)
        d3.selectAll(".highlighted").classed("highlighted", false);

        // Highlight the clicked node
        d3.select(this).classed("highlighted", true);

        // Highlight the connected nodes
        node.filter(d => connectedNodeIds.includes(d.id))
            .classed("highlighted", true);

        // Highlight links
        connectedNodeIds.push(clickedNode);        
        link.classed("highlighted_link", d=> (connectedNodeIds.includes(d.source.id) && d.target.id==clickedNode.id) || 
                                             (d.source.id==clickedNode.id && connectedNodeIds.includes(d.target.id)));   

        // recenter plot on clicked node
        const translateX = width / 2 - clickedNode.x; // Adjust to center horizontally
        const translateY = height / 2 - clickedNode.y; // Adjust to center vertically
        svg.transition().duration(500).call(
            zoom.transform,
            d3.zoomIdentity.translate(translateX, translateY)
        );

        // Update the details div.
        node2html(clickedNode, function(htmlContent) {
            d3.select("#details")
            .html(htmlContent);                    
        });

        // Prevent propagation of the click event to the SVG canvas
        event.stopPropagation();                
    }

    // Fetch html of entity details.
    function node2html(node, callback) {
        // Return html content for this entity.
        fetch('/entity/?type=' + node.entity_type + '&key=' + node.key)
          .then(response => {
            if (!response.ok) {
              throw new Error('Network response was not ok');
            }
            return response.text();
          })
          .then(html => {
            const tempContainer = document.createElement('div');
            d3.select(tempContainer).html(html);
            // Select the specific <div> element you want
            const targetDiv = tempContainer.querySelector('#entity');
            if (targetDiv) {
              callback(targetDiv.innerHTML);
            } else {
              console.error('The specified div was not found in the HTML');
            }
          })
          .catch(error => {
            console.error('There was a problem fetching the HTML:', error);
          });
    }
    
    // Create a zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.08, 4]) // Limit zoom scale
        .on("zoom", zoomed);

    // Apply zoom behavior to the SVG element
    svg.call(zoom).on("zoom", zoomed);

    // Define the zoomed function to handle zooming and panning
    function zoomed(event) {
        network_group.attr("transform", event.transform);
        // // Access the zoom scale (k)
        // zoomScale = transform.k;
    }

    // Filter nodes based on search query
    function filterNodes(searchQuery) {
        if (searchQuery) {
            const filteredNodes = nodes.filter(node => node.name.toLowerCase().includes(searchQuery.toLowerCase()));
            const filteredNodeIds = filteredNodes.map(node => node.id);

            // Update node selection to display only filtered nodes
            // ... or just highlight them.       
            if (filteredNodes.length != 0) {
                node.classed("highlighted", d => filteredNodeIds.includes(d.id));
                const connectedNodeIds = [];
                // Iterate through links to find connected nodes
                links.forEach(link => {
                    if (filteredNodeIds.includes(link.source.id)) {
                        connectedNodeIds.push(link.target.id);
                    }
                    if (filteredNodeIds.includes(link.target.id)) {
                        connectedNodeIds.push(link.source.id);
                    }
                });
                connectedNodeIds.push(...filteredNodeIds);  
                link.classed("highlighted_link", d=> 
                    (connectedNodeIds.includes(d.source.id) && connectedNodeIds.includes(d.target.id)));   
                const n = filteredNodes[0];
                const translateX = width / 2 - n.x; // Adjust to center horizontally
                const translateY = height / 2 - n.y; // Adjust to center vertically
                svg.transition().duration(500).call(
                    zoom.transform,
                    d3.zoomIdentity.translate(translateX, translateY)
                );

                // // Show description.
                // node2html(n, function(htmlContent) {
                //     d3.select("#details")
                //     .html(htmlContent);                    
                // });
            }
        } else {
            node.classed("highlighted", false);
        }
    }

    // Get what is typed into search bar.
    function getQueryParam(param) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(param);
    }

    // Listen for search input field.
    document.getElementById("searchInput").addEventListener("input", function() {
        const searchQuery = this.value.trim();
        filterNodes(searchQuery);
    });

    // Initialize autocomplete for the search input field
    $(function() {
        const searchTerm = getQueryParam("search"); // Get search term from URL query parameter

        // Initialize autocomplete
        $("#searchInput").autocomplete({
            source: function(request, response) {
                const term = request.term.toLowerCase();
                const filteredNodes = nodes.filter(node => node.name.toLowerCase().includes(term));
                const nodeNames = filteredNodes.map(node => node.name);
                response(nodeNames);
            },
            minLength: 1,
            select: function(event, ui) {
                const selectedNodeName = ui.item.value;
                filterNodes(selectedNodeName);
            }
        });

        // Set search input field value
        $("#searchInput").val(searchTerm);

        // Manually trigger filtering based on search query
        filterNodes(searchTerm);

        // Event listener for input event on search input field
        $("#searchInput").on("input", function() {
            const searchQuery = $(this).val().trim();
            filterNodes(searchQuery);
        });
    });        

</script>
{% endblock %}