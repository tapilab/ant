{% extends "base.html" %}
{% load static %}
{% block css %}
    <style>
        .node {
            stroke: #fff;
            stroke-width: 2px;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        
        .mytooltip {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 5px;
            display: none;
            max-width: 200px; /* Set maximum width here */
        }
        .highlighted {
            /* fill: yellow; /* Change the fill color to highlight */
            stroke: black;
            stroke-width: 4px;
            r: 20;
        }        
        #searchContainer {
            position: absolute;
            top: 100px; /* Adjust the top position as needed */
            left: 50px; /* Adjust the left position as needed */
            z-index: 500; /* Ensure the search input is above other elements */
        }        
    </style>
{% endblock %}

{% block content %}
    <div id="searchContainer">
        <input type="text" id="searchInput" placeholder="Search for nodes...">
    </div>
    <svg id="network" width="800" height="600"></svg>
    <div id="mytooltip" class="mytooltip">
        <div id="mytooltipText"></div>
    	<img id="mytooltipImage" src="" alt="Tooltip Image" style="max-width: 100px; max-height: 100px;">
    </div>
{% endblock %}

{% block scripts %}
    <script>
        const svg = d3.select("#network"),
            width = +svg.attr("width"),
            height = +svg.attr("height");

		var networkData = {{ network_json|safe }};
		const nodes = networkData.nodes;
		const links = networkData.links;

        const link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(links)
            .enter().append("line")
            .attr("class", "link")
            .attr("stroke-width", 2);

        const node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("class", "node")
            .attr("r", 8)
            .attr("fill", d => d.color)
            .on("mouseover", showTooltip)
            .on("mouseout", hideTooltip)
            .on("click", handleClick);

        node.append("title")
            .text(d => d.name);

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-100))
            .force("center", d3.forceCenter(width / 2, height / 2));

        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        });

        function showTooltip(event, d) {
            const tooltip = d3.select("#mytooltip");
            const tooltipImage = d3.select("#mytooltipImage");
            const tooltipText = d3.select("#mytooltipText");

            tooltipText.text(d.name);

			if (d.image_url) {
		        tooltipImage.style("display", "block")
		                     .attr("src", d.image_url);
			} else {
		        tooltipImage.style("display", "none");
			}

            tooltip.style("display", "block")
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 20) + "px");
        }

        function hideTooltip() {
            d3.select("#mytooltip").style("display", "none");
        }


        // Add a click event listener to the SVG canvas
        svg.on("click", () => {
            // Remove the highlighted class from all nodes
            node.classed("highlighted", false);
        });

        // Define the handleClick function
        function handleClick(event, clickedNode) {
            // Check if the clicked node is already highlighted
            const isHighlighted = d3.select(this).classed("highlighted");
            // Get the IDs of connected nodes
            const connectedNodeIds = links
                .filter(link => link.source === clickedNode || link.target === clickedNode)
                .map(link => link.source === clickedNode ? link.target.id : link.source.id);
            if (isHighlighted) {
                // Remove highlighting from this node and connected
                d3.select(this).classed("highlighted", false);
                node.filter(d => connectedNodeIds.includes(d.id))
                    .classed("highlighted", false);
            } else {
                // Remove highlighting from previously clicked nodes (if any)
                d3.selectAll(".highlighted").classed("highlighted", false);

                // Highlight the clicked node
                d3.select(this).classed("highlighted", true);

                // Highlight the connected nodes
                node.filter(d => connectedNodeIds.includes(d.id))
                    .classed("highlighted", true);
            }
            // Prevent propagation of the click event to the SVG canvas
            event.stopPropagation();                
        }

        // Function to filter nodes based on search query
        function filterNodes(searchQuery) {
            console.log('filter. search='+searchQuery)
            if (searchQuery) {
                const filteredNodes = nodes.filter(node => node.name.toLowerCase().includes(searchQuery.toLowerCase()));
                const filteredNodeIds = filteredNodes.map(node => node.id);

                // Update node selection to display only filtered nodes
                // ... or just highlight them.            
                node.classed("highlighted", d => filteredNodeIds.includes(d.id));
                // node
                //     .style("display", d => filteredNodeIds.includes(d.id) ? "block" : "none");

                // // Update link selection to display only links connected to filtered nodes
                // link
                //     .style("display", d => filteredNodeIds.includes(d.source.id) && filteredNodeIds.includes(d.target.id) ? "block" : "none");
            } else {
                node.classed("highlighted", false);
            }
        }

        function getQueryParam(param) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(param);
        }
        // Event listener for search input field
        document.getElementById("searchInput").addEventListener("input", function() {
            const searchQuery = this.value.trim();
            filterNodes(searchQuery);
        });

        // Initialize autocomplete for the search input field
        $(function() {
            const searchTerm = getQueryParam("search"); // Get search term from URL query parameter

            // Initialize autocomplete
            $("#searchInput").autocomplete({
                source: function(request, response) {
                    const term = request.term.toLowerCase();
                    const filteredNodes = nodes.filter(node => node.name.toLowerCase().includes(term));
                    const nodeNames = filteredNodes.map(node => node.name);
                    response(nodeNames);
                },
                minLength: 1,
                select: function(event, ui) {
                    const selectedNodeName = ui.item.value;
                    filterNodes(selectedNodeName);
                }
            });

            // Set search input field value
            $("#searchInput").val(searchTerm);

            // Manually trigger filtering based on search query
            filterNodes(searchTerm);

            // Event listener for input event on search input field
            $("#searchInput").on("input", function() {
                const searchQuery = $(this).val().trim();
                filterNodes(searchQuery);
            });
        });        

    </script>
{% endblock %}